# Менеджери розташування (Layouts): адаптивні інтерфейси

### **Вступ**

Створення адаптивного та зручного для користувача інтерфейсу є ключовим аспектом розробки сучасних програм. У фреймворку Qt це досягається за допомогою системи менеджерів розташування (Layouts). Ці менеджери автоматично впорядковують та змінюють розмір дочірніх віджетів у межах батьківського віджета, забезпечуючи ефективне використання доступного простору та гарантуючи послідовний та зручний інтерфейс користувача незалежно від розміру вікна чи змін вмісту.

### **Призначення менеджерів розташування**

Коли ви застосовуєте менеджер розташування до певного віджета (який стає його батьківським контейнером), цей менеджер бере на себе повну відповідальність за організацію всіх дочірніх віджетів усередині. Це значно спрощує процес розробки та забезпечує високу адаптивність. Основні завдання, які виконують менеджери розташування, включають:

* **Автоматичне позиціювання дочірніх віджетів**: Замість того, щоб вручну обчислювати координати та розміри кожного віджета, менеджер розташування робить це автоматично, дотримуючись визначених правил (наприклад, горизонтально, вертикально, у сітці). Це усуває необхідність у жорстко закодованих позиціях, які можуть виглядати некоректно при зміні розміру вікна.  
* **Надання розумних розмірів за замовчуванням та мінімальних розмірів для вікон**: Менеджери розташування враховують бажані та мінімальні розміри кожного віджета, що дозволяє їм автоматично пропонувати оптимальні початкові розміри для вікна, яке містить ці віджети. Це гарантує, що всі елементи інтерфейсу будуть видимими та доступними з самого початку.  
* **Ефективне керування зміною розмірів**: Коли користувач змінює розмір вікна, менеджери розташування динамічно перерозподіляють простір між дочірніми віджетами. Вони розтягують або стискають віджети відповідно до їхніх політик розміру, запобігаючи обрізанню елементів або появі надмірного порожнього простору.  
* **Автоматичне оновлення компонування при зміні вмісту**: Інтерфейс автоматично перекомпонується, якщо змінюється вміст віджетів. Це може бути зміна розміру шрифту, оновлення тексту, приховування або відображення віджетів, або навіть повне видалення віджета. Менеджер розташування гарантує, що інтерфейс завжди залишається узгодженим та правильно відображеним.

### **Основні менеджери розташування Qt**

Qt пропонує набір вбудованих менеджерів розташування, які покривають переважну більшість потреб у компонуванні інтерфейсів. Їхня простота використання та гнучкість роблять їх основою для будь-якого Qt-додатку.

1. QHBoxLayout (Горизонтальний менеджер):  
   Цей менеджер розташовує віджети поруч, зліва направо. Він ідеально підходить для створення рядків кнопок, полів введення або інших елементів, які повинні бути вирівняні по горизонталі. Коли вікно змінює розмір, віджети всередині QHBoxLayout автоматично адаптуються, намагаючись зайняти доступний горизонтальний простір відповідно до їхніх політик розміру.  
   Приклад: Три кнопки, розташовані горизонтально.  
```C++  
 QWidget *window = new QWidget;
    QPushButton *button1 = new QPushButton("One");
    QPushButton *button2 = new QPushButton("Two");
    QPushButton *button3 = new QPushButton("Three");
    QPushButton *button4 = new QPushButton("Four");
    QPushButton *button5 = new QPushButton("Five");

    QHBoxLayout *layout = new QHBoxLayout(window);
    layout->addWidget(button1);
    layout->addWidget(button2);
    layout->addWidget(button3);
    layout->addWidget(button4);
    layout->addWidget(button5);

    window->show();  
```
![](images/qhboxlayout.png)

2. QVBoxLayout (Вертикальний менеджер):  
   QVBoxLayout розміщує віджети один під одним, зверху вниз. Він є ідеальним вибором для створення стовпців елементів інтерфейсу, таких як меню, списки опцій або вертикальні групи контролів.  
   Приклад: Три кнопки, розташовані вертикально.  
```C++  
QWidget *window = new QWidget;
QPushButton *button1 = new QPushButton("One");
QPushButton *button2 = new QPushButton("Two");
QPushButton *button3 = new QPushButton("Three");
QPushButton *button4 = new QPushButton("Four");
QPushButton *button5 = new QPushButton("Five");

QVBoxLayout *layout = new QVBoxLayout(window);
layout->addWidget(button1);
layout->addWidget(button2);
layout->addWidget(button3);
layout->addWidget(button4);
layout->addWidget(button5);

window->show();
```
![](images/qvboxlayout.png)

3. QGridLayout (Сітковий менеджер):  
   QGridLayout є одним з найпотужніших та найгнучкіших менеджерів. Він дозволяє розташовувати віджети у двовимірній сітці, вказуючи конкретний рядок та стовпець для кожного віджета. Крім того, віджети можуть займати кілька рядків або стовпців (span), що робить його ідеальним для складних, табличних макетів, таких як форми або калькулятори.  
   Приклад: Калькулятор з кнопками, розташованими в сітці.  
```C++  
  QWidget *window = new QWidget;
    QPushButton *button1 = new QPushButton("One");
    QPushButton *button2 = new QPushButton("Two");
    QPushButton *button3 = new QPushButton("Three");
    QPushButton *button4 = new QPushButton("Four");
    QPushButton *button5 = new QPushButton("Five");

    QGridLayout *layout = new QGridLayout(window);
    layout->addWidget(button1, 0, 0);
    layout->addWidget(button2, 0, 1);
    layout->addWidget(button3, 1, 0, 1, 2);
    layout->addWidget(button4, 2, 0);
    layout->addWidget(button5, 2, 1);

    window->show();
```

![](images/qgridlayout.png)

4. QFormLayout (Менеджер форм):  
   QFormLayout спеціально розроблений для створення форм введення даних. Він автоматично створює двостовпцевий макет, де лівий стовпець зазвичай містить мітки (labels), а правий — відповідні поля введення (input fields) або інші віджети. Це забезпечує чистий та послідовний вигляд для форм.  
   Приклад: Форма входу з полями "Ім'я користувача" та "Пароль".  
```C++
    QWidget *window = new QWidget;
    QPushButton *button1 = new QPushButton("One");
    QLineEdit *lineEdit1 = new QLineEdit();
    QPushButton *button2 = new QPushButton("Two");
    QLineEdit *lineEdit2 = new QLineEdit();
    QPushButton *button3 = new QPushButton("Three");
    QLineEdit *lineEdit3 = new QLineEdit();

    QFormLayout *layout = new QFormLayout(window);
    layout->addRow(button1, lineEdit1);
    layout->addRow(button2, lineEdit2);
    layout->addRow(button3, lineEdit3);

    window->show();
```
![](images/qformlayout.png)

### Вкладення менеджерів розташування:  
Однією з найпотужніших можливостей Qt Layouts є можливість їхнього вкладення. Це дозволяє створювати надзвичайно складні та гнучкі макети, комбінуючи різні типи менеджерів. Наприклад, ви можете мати QVBoxLayout як основний макет для всього вікна, а всередині нього розмістити QHBoxLayout для групи кнопок у нижній частині, або QGridLayout для центральної області з даними. Це дає змогу розбивати складний інтерфейс на менші, керовані частини.

### **Поради щодо використання менеджерів розташування**

* **Батьківський віджет та управління пам'яттю**: При створенні дочірніх віджетів, які будуть додані до менеджера розташування, вам зазвичай не потрібно явно вказувати батьківський віджет у конструкторі. Менеджер розташування автоматично "перебатькує" (reparent) віджети до віджета, на якому встановлений сам менеджер. Це також спрощує управління пам'яттю, оскільки при видаленні батьківського віджета (або менеджера розташування) всі його дочірні віджети також будуть автоматично видалені.  
* Розподіл простору та sizePolicy() / sizeHint():  
  Віджетам виділяється простір на основі двох ключових властивостей: sizePolicy() та sizeHint().  
  * **sizeHint()**: Це "бажаний" розмір віджета. Кожен віджет у Qt має sizeHint(), який повертає рекомендований розмір для цього віджета, враховуючи його вміст (наприклад, текст кнопки, розмір зображення). Менеджери розташування намагаються надати віджетам простір, близький до їхнього sizeHint().  
  * **sizePolicy()**: Це властивість, яка визначає, як віджет повинен поводитися, коли доступного простору більше або менше, ніж його sizeHint(). Вона складається з двох компонентів: горизонтальної та вертикальної політики. Типові значення QSizePolicy включають:  
    * Fixed: Віджет зберігає свій sizeHint() і не розтягується.  
    * Preferred: Віджет віддає перевагу своєму sizeHint(), але може розтягуватися або стискатися.  
    * Expanding: Віджет може розтягуватися, щоб зайняти весь доступний простір, і йому надається пріоритет над іншими віджетами.  
    * MinimumExpanding: Подібно до Expanding, але віджет не стискається нижче свого minimumSizeHint().  
    * Ignored: Віджет ігнорує свій sizeHint() і може бути стиснутий до мінімуму або розтягнутий до максимуму.  
      Розуміння та правильне налаштування sizePolicy() є критично важливим для створення адаптивних інтерфейсів.  
* Коефіцієнти розтягування (Stretch Factors):  
  Коефіцієнти розтягування використовуються в QHBoxLayout та QVBoxLayout для контролю пропорційного розподілу зайвого простору між віджетами. Коли доступного простору більше, ніж потрібно всім віджетам за їхніми sizeHint(), цей "зайвий" простір розподіляється між віджетами пропорційно їхнім коефіцієнтам розтягування. Віджет з коефіцієнтом 2 отримає вдвічі більше додаткового простору, ніж віджет з коефіцієнтом 1\. Якщо коефіцієнт розтягування дорівнює 0 (за замовчуванням), віджет не отримує додаткового простору. Це дозволяє одному віджету займати більше місця, ніж іншому, коли вікно розтягується.  
  Приклад:  
```C++
QHBoxLayout* layout = new QHBoxLayout();
layout->addWidget(new QPushButton("Мала"), 1); // Отримає 1 частину простору
layout->addWidget(new QPushButton("Велика"), 3); // Отримає 3 частини простору
```

### **Робота з власними віджетами**

Коли ви створюєте власний (кастомний) віджет, який має бути інтегрований у систему компонування Qt, надзвичайно важливо правильно повідомити менеджерам розташування про його бажані розміри та поведінку. Для цього розробники повинні перевизначити такі віртуальні функції класу QWidget:

* **QWidget::sizeHint()**: Ця функція повинна повертати "ідеальний" розмір для вашого віджета, тобто розмір, при якому він виглядає найкраще і весь його вміст повністю видимий. Наприклад, для текстового віджета це може бути розмір, необхідний для відображення всього тексту з поточним шрифтом.  
* **QWidget::minimumSizeHint()**: Ця функція повертає мінімальний розмір, нижче якого віджет не повинен стискатися. Це запобігає тому, щоб віджет став занадто малим і його вміст став нечитабельним або недоступним.  
* **QWidget::setSizePolicy()**: Ця функція встановлює політику розміру віджета, як було описано вище. Вона визначає, як віджет повинен розтягуватися або стискатися в горизонтальному та вертикальному напрямках.

При зміні внутрішнього вмісту вашого кастомного віджета, що може вплинути на його бажаний розмір (наприклад, зміна тексту, зображення), слід викликати QWidget::updateGeometry(). Цей виклик повідомляє батьківському менеджеру розташування, що розмір віджета, можливо, змінився, і ініціює перерахунок макета для всього вікна.

### **Створення власного менеджера розташування**

Хоча стандартні менеджери розташування Qt покривають більшість сценаріїв, іноді виникають дуже специфічні потреби в компонуванні, які не можуть бути ефективно реалізовані за допомогою наявних класів. У таких випадках Qt надає можливість створити власний менеджер розташування, успадкувавши його від абстрактного класу QLayout.  
Створення власного менеджера розташування є складнішим завданням і вимагає глибокого розуміння того, як працює система компонування Qt. Вам потрібно буде реалізувати кілька віртуальних функцій, які визначають поведінку вашого макета:

* **addItem(QLayoutItem\* item)**: Додає елемент (віджет або інший макет) до вашого кастомного менеджера.  
* **setGeometry(const QRect& rect)**: Ця функція є серцем вашого макета. Вона отримує доступний прямокутник (розмір і позицію) і повинна обчислити та встановити розміри та позиції для всіх дочірніх елементів.  
* **sizeHint()**: Повертає бажаний розмір для всього макета.  
* **minimumSize()**: Повертає мінімальний розмір, нижче якого макет не повинен стискатися.  
* **itemAt(int index)**: Повертає елемент макета за вказаним індексом.  
* **takeAt(int index)**: Видаляє елемент макета за вказаним індексом.

Реалізація цих функцій дозволяє створити абсолютно унікальні правила компонування, адаптовані до конкретних вимог вашого додатку.


### **Додаткові матеріали для вивчення:**

* [Офіційна документація Qt 6 по компонуванню](https://doc.qt.io/qt-6/layout.html)  
* [Відеоуроки з Qt Layouts (приклади на YouTube)](https://www.google.com/search?q=https://www.youtube.com/results?search_query%3DQt%2BLayouts%2Btutorial)  
