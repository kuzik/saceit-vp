# Події: миша, клавіатура, таймери

У будь-якому інтерактивному додатку взаємодія з користувачем є ключовим елементом. Qt надає гнучку та ефективну систему обробки подій. Події – це сигнали, що генеруються системою або користувачем у відповідь на певні дії, такі як натискання кнопки миші, введення символу з клавіатури, або спрацювання таймера. Розуміння та правильна обробка цих подій є фундаментальним для створення динамічних та чутливих до дій користувача програм.

## Механізм обробки подій у Qt

Qt використовує підхід при якому кожна подія представлена об'єктом класу `QEvent` або одним з його численних похідних класів (наприклад, `QMouseEvent`, `QKeyEvent`, `QTimerEvent`, `QResizeEvent`, `QPaintEvent` тощо). Ці об'єкти інкапсулюють всю необхідну інформацію про подію, таку як тип події, координати (для подій миші), код клавіші (для подій клавіатури) або ідентифікатор таймера.

Коли відбувається подія (наприклад, користувач клацає мишею по віджету), Qt створює відповідний об'єкт події та надсилає його відповідному об'єкту (зазвичай, віджету, який отримав фокус або знаходиться під курсором миші). Цей об'єкт отримує подію через свій віртуальний метод `event(QEvent *event)`. Цей метод є центральною точкою для обробки всіх подій, що надходять до об'єкта. Зазвичай, `event()` не обробляє події безпосередньо, а викликає спеціалізовані, захищені віртуальні обробники для конкретних типів подій (наприклад, `mousePressEvent()` для натискання миші, `keyPressEvent()` для натискання клавіші).

**Цикл подій (Event Loop):** Усі події в Qt обробляються в рамках циклу подій. Це нескінченний цикл, який постійно перевіряє наявність нових подій у черзі подій. Коли подія надходить, вона витягується з черги та відправляється відповідному об'єкту. Цей цикл запускається викликом `QApplication::exec()` у вашій головній функції `main()`.

Розробники мають кілька способів обробки подій, кожен з яких пропонує різний рівень контролю:

- Перевизначення спеціалізованих обробників подій: Це найпоширеніший, найпростіший та рекомендований спосіб для більшості випадків. Більшість віджетів мають віртуальні методи, такі як `mousePressEvent()`, `keyPressEvent()`, `paintEvent()`, `resizeEvent()` тощо. Ви можете успадкувати свій власний клас від існуючого віджета та перевизначити ці методи, щоб додати власну логіку обробки подій. Якщо ви повністю обробили подію і не хочете, щоб вона поширювалася далі, ви повинні викликати `event->accept()`. Якщо ви хочете, щоб подія продовжувала свій шлях (наприклад, до батьківського віджета), ви повинні викликати `event->ignore()` або не викликати `accept()`.
```c++
void MyCheckBox::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        // handle left mouse button here
    } else {
        // pass on other buttons to base class
        QCheckBox::mousePressEvent(event);
    }
}
```

- Перевизначення `event()`: Для більш низькорівневої обробки або для обробки подій, для яких немає спеціалізованих обробників (наприклад, `QEvent::HoverEnter`, `QEvent::Drop`). У цьому методі ви можете використовувати `event->type()` для визначення типу події та відповідним чином її обробити. Якщо ви обробили подію, поверніть `true`; інакше, викличте базовий клас `QWidget::event(event)` і поверніть його результат.
```c++
bool MyWidget::event(QEvent *event)
{
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent *ke = static_cast<QKeyEvent *>(event);
        if (ke->key() == Qt::Key_Tab) {
            // special tab handling here
            return true;
        }
    } else if (event->type() == MyCustomEventType) {
        MyCustomEvent *myEvent = static_cast<MyCustomEvent *>(event);
        // custom event handling here
        return true;
    }

    return QWidget::event(event);
}
```

- Фільтри подій: Дозволяють одному об'єкту (фільтру) перехоплювати та обробляти події, призначені для іншого об'єкта, до того, як вони досягнуть свого цільового об'єкта. Це потужний механізм для реалізації глобальної обробки подій або для зміни поведінки стандартних віджетів без їхнього успадкування.
```c++
bool FilterObject::eventFilter(QObject *object, QEvent *event)
{
    if (object == target && event->type() == QEvent::KeyPress) {
        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
        if (keyEvent->key() == Qt::Key_Tab) {
            // Special tab handling
            return true;
        } else
            return false;
    }
    return false;
}
```

## Події миші
Події миші виникають, коли користувач взаємодіє з мишею над віджетом. Об'єкт `QMouseEvent` надає детальну інформацію про подію.

- `mousePressEvent(QMouseEvent *event)`: Викликається, коли будь-яка кнопка миші натиснута.

    - `event->button()`: Повертає кнопку, яка спричинила подію (наприклад, `Qt::LeftButton`, `Qt::RightButton`, `Qt::MidButton`).

    - `event->buttons()`: Повертає стан усіх кнопок миші, які наразі натиснуті (комбінація прапорів).

    - `event->pos()`: Повертає координати курсору відносно віджета, який отримав подію.

    - `event->globalPos()`: Повертає координати курсору відносно екрана.

    - `event->modifiers()`: Повертає стан клавіш-модифікаторів (Shift, Ctrl, Alt) під час події.

- `mouseReleaseEvent(QMouseEvent *event)`: Викликається, коли кнопка миші відпущена. Зазвичай використовується в парі з `mousePressEvent` для визначення повного циклу натискання-відпускання.

- `mouseMoveEvent(QMouseEvent *event)`: Викликається, коли курсор миші переміщується над віджетом. Важливо: За замовчуванням, ця подія генерується лише тоді, коли одна з кнопок миші натиснута. Щоб отримувати події переміщення миші без натиснутої кнопки (наприклад, для реалізації ефектів наведення), необхідно увімкнути "відстеження миші" для віджета за допомогою `setMouseTracking(true)`.

- `mouseDoubleClickEvent(QMouseEvent *event)`: Викликається при подвійному натисканні кнопки миші. Ця подія генерується після другого `mousePressEvent`.
  
```c++
void MainWindow::mouseReleaseEvent(QMouseEvent *event)
{
    ui->label->setText(QString("Кнопка миші відпущена в: (%1, %2)").arg(event->pos().x()).arg(event->pos().y()));
    qDebug() << "Mouse Release Event: " << ui->label->text();
    QWidget::mouseReleaseEvent(event);
}

void MainWindow::mouseMoveEvent(QMouseEvent *event)
{
    // Ця подія буде спрацьовувати лише якщо setMouseTracking(true) або кнопка миші натиснута
    ui->label->setText(QString("Миша переміщена до: (%1, %2)").arg(event->pos().x()).arg(event->pos().y()));
    // qDebug() << "Mouse Move Event: " << statusLabel->text();
    QWidget::mouseMoveEvent(event);
}

void MainWindow::mouseDoubleClickEvent(QMouseEvent *event)
{
    ui->label->setText(QString("Подвійний клік Лівою кнопкою в: (%1, %2)").arg(event->pos().x()).arg(event->pos().y()));
    qDebug() << "Mouse Double Click Event: " << ui->label->text();
    QWidget::mouseDoubleClickEvent(event);
}
```

## Події клавіатури

Події клавіатури виникають, коли користувач натискає або відпускає клавіші. Об'єкт QKeyEvent містить всю необхідну інформацію.

- `keyPressEvent(QKeyEvent *event)`: Викликається, коли клавіша натиснута.

    - `event->key()`: Повертає код натиснутої клавіші (наприклад, `Qt::Key_A`, `Qt::Key_Enter`, `Qt::Key_Up`). Це більш надійний спосіб ідентифікації клавіші, ніж `text()`.

    - `event->text()`: Повертає текстове представлення натиснутої клавіші (наприклад, "a", "A", " "). Це корисно для введення тексту.

    - `event->modifiers()`: Повертає стан клавіш-модифікаторів (Shift, Ctrl, Alt, Meta) під час події.

    - `event->isAutoRepeat()`: Повертає true, якщо подія є автоповтором (утримувана клавіша). Це дозволяє відфільтрувати повторні натискання, якщо це необхідно.

- `keyReleaseEvent(QKeyEvent *event)`: Викликається, коли клавіша відпущена.

**Важливо: Фокус введення (Input Focus):**
Віджет отримує події клавіатури лише тоді, коли він має фокус введення. Фокус введення – це стан, який вказує, який віджет наразі активний для отримання вводу з клавіатури.

- Отримання фокусу: Віджет може отримати фокус клацанням миші, натисканням клавіші Tab (перехід між віджетами) або програмно за допомогою `setFocus()`.

- Втрата фокусу: Віджет втрачає фокус, коли інший віджет отримує його, або коли вікно програми втрачає активність.

- `setFocusPolicy(Qt::FocusPolicy policy)`: Цей метод дозволяє контролювати, як віджет може отримувати фокус (наприклад, `Qt::StrongFocus` дозволяє отримувати фокус клацанням миші та Tab, `Qt::NoFocus` забороняє отримання фокусу).

```c++
void MainWindow::keyPressEvent(QKeyEvent *event)
{
    QString keyInfo;

    if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return) {
        keyInfo = "Натиснуто Enter!";
    } else if (event->key() == Qt::Key_Space) {
        keyInfo = "Натиснуто пробіл!";
    } else {
        keyInfo = "Натиснуто клавішу: " + event->text()
            + " (Код клавіші: " + QString::number(event->key()) + ")";
    }

    if (event->modifiers() & Qt::ControlModifier) {
        keyInfo += " + Ctrl";
    }
    if (event->modifiers() & Qt::ShiftModifier) {
        keyInfo += " + Shift";
    }
    if (event->modifiers() & Qt::AltModifier) {
        keyInfo += " + Alt";
    }

    ui->label_2->setText(keyInfo);
    qDebug() << keyInfo;

    QMainWindow::keyPressEvent(event);
}
```

## Таймери

Таймери дозволяють виконувати код через певні проміжки часу або один раз після заданої затримки. Це невід'ємний інструмент для реалізації анімації, періодичного оновлення даних (наприклад, годинник, моніторинг ресурсів), або затримки виконання певних дій (наприклад, спливаючі підказки).

Qt пропонує два основні способи використання таймерів, кожен з яких має свої переваги:

- `QTimer` клас: Це високоцільовий, зручний клас для таймерів, який є частиною механізму сигналів/слотів Qt. Він є рекомендованим способом для більшості застосувань.

    - Одноразовий таймер: Для виконання дії лише один раз після заданої затримки, використовуйте статичний метод `QTimer::singleShot(int msec, const QObject *receiver, const char *member)`. Це ідеально підходить для відкладених дій.

    - Повторюваний таймер: Для періодичного виконання дії, створіть об'єкт `QTimer`, встановіть інтервал за допомогою `timer->setInterval(msec)` (де msec – інтервал у мілісекундах), підключіть сигнал `timeout()` таймера до вашого слота, який буде виконувати необхідну дію, і запустіть таймер за допомогою `timer->start()`. Ви можете зупинити його за допомогою `timer->stop()`.

- `startTimer()` та `timerEvent()`: Це низькорівневий спосіб використання таймерів, який є частиною базового класу `QObject`. Він корисний, коли об'єкту потрібно керувати кількома таймерами або коли ви хочете уникнути накладних витрат на сигнали/слоти (хоча для більшості випадків різниця незначна).

    - Ви викликаєте `int timerId = startTimer(int interval)` на об'єкті (наприклад, віджеті). Цей метод повертає унікальний ідентифікатор таймера.

    - Коли таймер спрацьовує, генерується подія `QTimerEvent`, яка обробляється в перевизначеному методі `timerEvent(QTimerEvent *event)`. У цьому методі ви використовуєте `event->timerId()` для визначення, який саме таймер спрацював, і виконуєте відповідну логіку.

    - Щоб зупинити таймер, викликайте `killTimer(timerId)`.

Порівняння `QTimer` та `startTimer()`/`timerEvent()`:
  - `QTimer`: Простіший у використанні, особливо для одного таймера або коли потрібна взаємодія з іншими об'єктами через сигнали/слоти. Більш "Qt-шний" підхід.

  - `startTimer()`/`timerEvent()`: Більш низькорівневий, може бути ефективнішим для об'єкта, який керує багатьма таймерами, оскільки всі події таймерів обробляються в одному місці (`timerEvent`).

**Точність таймерів:** Таймери Qt працюють на основі системних таймерів. Їхня точність залежить від операційної системи та навантаження на систему. Вони не гарантують абсолютно точного спрацювання з мілісекундною точністю, особливо для дуже коротких інтервалів.

```c++
#include "MyTimerWidget.h"

MyTimerWidget::MyTimerWidget(QWidget *parent) : QWidget(parent)
{
    timeLabel = new QLabel("Час: ", this);
    timeLabel->setAlignment(Qt::AlignCenter);
    timeLabel->setStyleSheet("font-size: 24px; color: blue;");

    toggleButton = new QPushButton("Зупинити таймер", this);
    timerRunning = true;

    QVBoxLayout *layout = new QVBoxLayout(this);
    layout->addWidget(timeLabel);
    layout->addWidget(toggleButton);
    setLayout(layout);

    timer = new QTimer(this); // 'this' встановлює батьківський об'єкт, забезпечуючи автоматичне видалення
    // Підключаємо сигнал timeout() таймера до нашого слота updateTime()
    connect(timer, &QTimer::timeout, this, &MyTimerWidget::updateTime);
    // Підключаємо сигнал натискання кнопки до слота toggleTimer()
    connect(toggleButton, &QPushButton::clicked, this, &MyTimerWidget::toggleTimer);

    // Встановлюємо інтервал таймера на 1000 мс (1 секунда)
    timer->setInterval(1000);
    // Запускаємо таймер
    timer->start();

    // Оновлюємо час одразу при створенні віджета, щоб він не був порожнім
    updateTime();
}

MyTimerWidget::~MyTimerWidget()
{
    // Таймер буде автоматично видалений, оскільки його батьківським об'єктом є MyTimerWidget
    // Якщо б timer не мав батьківського об'єкта, тут потрібно було б: delete timer;
}

void MyTimerWidget::updateTime()
{
    timeLabel->setText("Час: " + QDateTime::currentDateTime().toString("hh:mm:ss"));
}

void MyTimerWidget::toggleTimer()
{
    if (timerRunning) {
        timer->stop();
        toggleButton->setText("Запустити таймер");
        timerRunning = false;
        qDebug() << "Таймер зупинено.";
    } else {
        timer->start();
        toggleButton->setText("Зупинити таймер");
        timerRunning = true;
        qDebug() << "Таймер запущено.";
    }
}
```

## Фільтрація подій
Фільтри подій є потужним, але дещо складнішим механізмом, який дозволяє об'єкту перехоплювати всі події, що надсилаються іншому об'єкту, до того, як вони досягнуть свого цільового призначення. Це дає можливість реалізувати глобальну обробку подій (наприклад, відстеження всіх натискань клавіш у додатку) або змінити поведінку стандартних віджетів без необхідності їхнього успадкування.

Для встановлення фільтра подій використовується метод `installEventFilter(QObject *filterObj)` на об'єкті, події якого ви хочете фільтрувати. Об'єкт `filterObj (сам фільтр)` повинен успадковуватися від `QObject` та перевизначати метод `eventFilter(QObject *watched, QEvent *event)`.

**Як працює eventFilter():**
- `watched`: Це вказівник на об'єкт, за яким спостерігає фільтр (тобто об'єкт, якому була призначена подія).

- `event`: Це вказівник на об'єкт події, який фільтрується.

- **Повернене значення:**
  - Якщо `eventFilter()` повертає true, це означає, що фільтр повністю обробив подію, і вона не буде надсилатися цільовому об'єкту (watched) або його батьківським елементам. Подія "споживається" фільтром.

  - Якщо `eventFilter()` повертає false, подія продовжує свій шлях до цільового об'єкта (watched) для стандартної обробки (тобто, буде викликаний його `event()` метод, а потім, можливо, спеціалізовані обробники).

**Сценарії використання фільтрів подій:**
- Глобальні гарячі клавіші: Перехоплення певних комбінацій клавіш для виконання дій незалежно від того, який віджет має фокус.

- Зміна поведінки стандартних віджетів: Наприклад, заборона введення певних символів у `QLineEdit` або зміна реакції `QPushButton` на клік.

- Інструменти налагодження: Моніторинг усіх подій, що надходять до певного віджета або групи віджетів.

- Кастомні контекстні меню: Перехоплення подій правої кнопки миші для відображення власного меню.

**Важливо враховувати кілька аспектів при використанні фільтрів подій:**
- Порядок фільтрів: Якщо на один об'єкт встановлено кілька фільтрів, вони застосовуються в порядку їх встановлення.

- Продуктивність: Надмірне використання фільтрів подій або складна логіка всередині `eventFilter()` може вплинути на продуктивність, оскільки кожна подія для відфільтрованого об'єкта проходить через фільтр.

- Відлагодження: Фільтри подій можуть ускладнити відлагодження, оскільки вони можуть "споживати" події, які ви очікували побачити в обробниках віджета.

Приклад використання фільтра подій для перехоплення та фільтрації натискання клавіш:

```c++
MyEventFilter::MyEventFilter(QObject *parent) : QObject(parent) {}

bool MyEventFilter::eventFilter(QObject *watched, QEvent *event)
{
    // Фільтруємо події натискання клавіш
    if (event->type() == QEvent::KeyPress) {
        QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);
        qDebug() << "Фільтр перехопив натискання клавіші на об'єкті" << watched->objectName()
                 << ": " << keyEvent->text() << " (Key Code: " << keyEvent->key() << ")";

        // Приклад: Блокуємо натискання клавіші 'X' для будь-якого віджета, за яким спостерігаємо
        if (keyEvent->key() == Qt::Key_X) {
            qDebug() << "Заблоковано натискання клавіші 'X' для " << watched->objectName() << "!";
            return true; // Подія оброблена, не передаємо її далі
        }
        // Приклад: Якщо натиснуто Ctrl+S, виводимо повідомлення і блокуємо
        if (keyEvent->key() == Qt::Key_S && (keyEvent->modifiers() & Qt::ControlModifier)) {
            qDebug() << "Глобальна гаряча клавіша Ctrl+S спрацювала для " << watched->objectName() << "!";
            return true; // Блокуємо подальшу обробку
        }
    }
    // Фільтруємо події подвійного кліку миші
    else if (event->type() == QEvent::MouseButtonDblClick) {
        QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
        qDebug() << "Фільтр перехопив подвійний клік на об'єкті" << watched->objectName()
                 << " в позиції: (" << mouseEvent->pos().x() << ", " << mouseEvent->pos().y() << ")";


    // Передаємо подію далі для стандартної обробки, якщо вона не була оброблена фільтром
    return QObject::eventFilter(watched, event);
}
```

## Додаткові матеріали для вивчення:
- [Офіційна документація Qt 6 по системі подій](https://doc.qt.io/qt-6/eventsandfilters.html)
- [Офіційна документація Qt 6 по QMouseEvent](https://doc.qt.io/qt-6/qmouseevent.html)
- [Офіційна документація Qt 6 по QKeyEvent](https://doc.qt.io/qt-6/qkeyevent.html)
- [Офіційна документація Qt 6 по QTimer](https://doc.qt.io/qt-6/qtimer.html)