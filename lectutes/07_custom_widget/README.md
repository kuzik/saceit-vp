# Створення власного віджета в Qt

Qt надає багатий набір готових віджетів (кнопок, текстових полів, міток, таблиць тощо), які покривають більшість потреб у розробці графічних інтерфейсів. Однак, у складних або унікальних проектах часто виникає потреба у функціональності, яку неможливо реалізувати за допомогою стандартних компонентів, або ж потрібно значно змінити їхню поведінку чи зовнішній вигляд. У таких випадках на допомогу приходить можливість створення власних віджетів.

Створення власного віджета дозволяє розробникам повністю контролювати його поведінку, малювання та взаємодію з користувачем, адаптуючи його до специфічних вимог проекту. Це відкриває двері для реалізації унікальних візуалізацій, спеціалізованих елементів керування або оптимізованих компонентів, які ідеально вписуються в дизайн та функціонал вашої програми.

## Переваги створення власних віджетів

Розробка власних віджетів є потужним інструментом у арсеналі Qt-розробника, що надає низку значних переваг:

1. **Гнучкість та повна кастомізація:**
Стандартні віджети Qt, хоч і гнучкі, мають свої обмеження. Створюючи власний віджет, ви отримуєте повний контроль над його зовнішнім виглядом та поведінкою. Ви можете малювати будь-які форми, лінії, текст, зображення, застосовувати складні анімації та реагувати на події користувача саме так, як вам потрібно. Це дозволяє реалізувати унікальні елементи інтерфейсу, які ідеально відповідають брендингу або специфічним вимогам дизайну вашої програми, чого неможливо досягти лише за допомогою стилів QSS або базових налаштувань.

2. **Повторне використання коду (Reusability):**
Власний віджет – це самодостатній компонент. Після його розробки та тестування ви можете багаторазово використовувати його в різних частинах однієї програми або навіть у різних проектах. Це значно прискорює розробку, зменшує кількість дубльованого коду та підвищує консистентність інтерфейсу в межах великого додатку або цілої лінійки продуктів. Наприклад, якщо ви розробили спеціалізований графік, ви можете використовувати його на різних екранах, просто додаючи його як звичайний віджет.

3. **Інкапсуляція логіки:**
Власний віджет дозволяє інкапсулювати складну логіку та дані всередині одного компонента. Наприклад, віджет для відображення даних сенсора може містити не лише логіку малювання, але й логіку отримання, обробки та оновлення цих даних. Це робить код більш модульним, легким для розуміння, підтримки та тестування. Замість розкиданої по всьому проекту логіки, вона акумулюється в одному місці, що значно спрощує налагодження.

4. **Оптимізація продуктивності:**
Для специфічних завдань, таких як відображення великих обсягів даних або складна графіка, стандартні віджети можуть бути неоптимальними. Створюючи власний віджет, ви можете оптимізувати процес малювання та обробки даних, використовуючи низькорівневі можливості Qt (наприклад, QPainter для ефективного малювання). Це дозволяє досягти кращої продуктивності та плавності роботи інтерфейсу, що є критично важливим для додатків з високими вимогами до графіки або інтерактивності.

5. **Покращений користувацький досвід:**
Унікальні та інтуїтивно зрозумілі віджети можуть значно покращити користувацький досвід. Замість того, щоб змушувати користувача адаптуватися до стандартних елементів, ви можете створити компоненти, які ідеально відповідають його ментальній моделі та робочому процесу. Це може призвести до більшої ефективності, меншої кількості помилок та загального задоволення від використання програми.

6. **Інтеграція з Qt Designer:**
Qt надає можливість інтегрувати власні віджети безпосередньо в Qt Designer. Це означає, що ви можете перетягувати та налаштовувати свої кастомні компоненти візуально, так само як і стандартні віджети, що значно прискорює дизайн інтерфейсу та дозволяє дизайнерам працювати з вашими компонентами без глибоких знань коду.

## Процес створення власного віджета
Створення власного віджета в Qt зазвичай включає кілька ключових кроків. Ми розглянемо їх послідовно.
1. Успадкування від базового віджета (QWidget або іншого)

Кожен віджет у Qt є похідним від класу `QObject` та `QWidget`. `QWidget` є базовим класом для всіх об'єктів користувацького інтерфейсу в Qt. Він надає базову функціональність для малювання, обробки подій, управління геометрією та інтеграції в систему компонування.

- Вибір базового класу: Для більшості власних віджетів, які малюють щось унікальне або мають специфічну інтерактивність, `QWidget` є ідеальним базовим класом. Якщо ж ваш віджет є модифікацією існуючого (наприклад, `QPushButton` з додатковим індикатором), ви можете успадкувати його безпосередньо від `QPushButton` або іншого відповідного віджета.

- Макрос `Q_OBJECT`: У заголовочному файлі вашого класу віджета обов'язково включіть макрос `Q_OBJECT`. Цей макрос необхідний для того, щоб ваш клас міг використовувати мета-об'єктну систему Qt, яка забезпечує такі функції, як сигнали та слоти, властивості (properties) та динамічне створення об'єктів. Без нього ви отримаєте помилки лінкування, пов'язані з vtable.

**Приклад структури класу:**
```cpp
// MyCustomWidget.h
#ifndef MYCUSTOMWIDGET_H
#define MYCUSTOMWIDGET_H

#include <QWidget> // Базовий клас для нашого віджета
#include <QPainter> // Для малювання
#include <QMouseEvent> // Для обробки подій миші
#include <QKeyEvent>   // Для обробки подій клавіатури
#include <QDebug>      // Для налагодження

class MyCustomWidget : public QWidget // Успадковуємося від QWidget
{
    Q_OBJECT // Обов'язковий макрос для мета-об'єктної системи Qt

public:
    explicit MyCustomWidget(QWidget *parent = nullptr); // Конструктор

    // Власні властивості віджета (докладніше нижче)
    Q_PROPERTY(QColor widgetColor READ widgetColor WRITE setWidgetColor NOTIFY widgetColorChanged)

    QColor widgetColor() const { return m_widgetColor; }
    void setWidgetColor(const QColor &color);

signals:
    void widgetColorChanged(const QColor &color); // Сигнал про зміну кольору

protected:
    // Перевизначені обробники подій
    void paintEvent(QPaintEvent *event) override;
    void mousePressEvent(QMouseEvent *event) override;
    void mouseMoveEvent(QMouseEvent *event) override;
    void keyPressEvent(QKeyEvent *event) override;

    // Перевизначення для підказок розміру
    QSize sizeHint() const override;
    QSize minimumSizeHint() const override;

private:
    QColor m_widgetColor; // Внутрішня змінна для зберігання кольору
    QPoint m_lastMousePos; // Для відстеження позиції миші
};

#endif // MYCUSTOMWIDGET_H
```

2. **Перевизначення** `paintEvent(QPaintEvent *event)`

Це найважливіший метод для візуалізації вашого віджета. Кожного разу, коли віджет потребує перемальовування (наприклад, при зміні розміру, оновленні даних, або коли частина віджета стає видимою), Qt викликає paintEvent().

   - `QPainter`: Для малювання використовується об'єкт `QPainter`. Він надає високооптимізовані функції для малювання ліній, кіл, прямокутників, тексту, зображень та інших графічних примітивів.

   - begin() та `end()`: Завжди створюйте об'єкт `QPainter` у стеку та ініціалізуйте його з this (вказівником на ваш віджет). `QPainter` автоматично викликає begin() у конструкторі та `end()` у деструкторі, що є найкращою практикою.

   - Малювання: Усередині paintEvent() ви виконуєте всі операції малювання. Пам'ятайте, що малювати потрібно лише в межах області, яку потрібно оновити (доступ до цієї області можна отримати через `event->rect()`).

**Приклад малювання простого кола:**
```cpp
// MyCustomWidget.cpp
#include "MyCustomWidget.h"
#include <QPainter> // Обов'язково включити для QPainter

MyCustomWidget::MyCustomWidget(QWidget *parent)
    : QWidget(parent), m_widgetColor(Qt::red) // Ініціалізуємо колір
{
    // Встановлюємо політику розміру за замовчуванням
    setSizePolicy(QSizePolicy::MinimumExpanding, QSizePolicy::MinimumExpanding);
    setMouseTracking(true); // Увімкнути відстеження миші для mouseMoveEvent без натискання
    setFocusPolicy(Qt::StrongFocus); // Дозволити віджету отримувати фокус клавіатури
}

void MyCustomWidget::paintEvent(QPaintEvent *event)
{
    Q_UNUSED(event); // Використовуємо, щоб уникнути попереджень про невикористаний параметр

    QPainter painter(this); // Створюємо об'єкт QPainter для малювання на цьому віджеті
    painter.setRenderHint(QPainter::Antialiasing); // Увімкнути згладжування для кращої якості

    // Малюємо фон віджета
    painter.fillRect(rect(), Qt::lightGray); // Заповнюємо весь віджет світло-сірим кольором

    // Встановлюємо колір пензля (для контуру) та пензля (для заповнення)
    painter.setPen(QPen(Qt::darkBlue, 2)); // Синій контур, товщина 2 пікселі
    painter.setBrush(m_widgetColor); // Заповнення кольором m_widgetColor

    // Малюємо коло (або овал) по центру віджета
    int radius = qMin(width(), height()) / 2 - 10; // Радіус, щоб коло не торкалося країв
    painter.drawEllipse(rect().center(), radius, radius); // Малюємо коло по центру

    // Малюємо текст
    painter.setPen(Qt::black); // Колір тексту - чорний
    painter.drawText(rect(), Qt::AlignCenter, tr("Мій власний віджет")); // Текст по центру
}

void MyCustomWidget::setWidgetColor(const QColor &color)
{
    if (m_widgetColor != color) {
        m_widgetColor = color;
        emit widgetColorChanged(m_widgetColor); // Випромінюємо сигнал про зміну кольору
        update(); // Викликаємо update() для перемальовування віджета
    }
}
```

3 **Обробка подій (миша, клавіатура)**

Для того, щоб ваш віджет був інтерактивним, ви повинні перевизначити відповідні обробники подій, успадковані від QWidget.

   - Події миші:
      - `mousePressEvent(QMouseEvent *event)`: Натискання кнопки миші.
      - `mouseReleaseEvent(QMouseEvent *event)`: Відпускання кнопки миші.
      - `mouseMoveEvent(QMouseEvent *event)`: Переміщення курсору миші. Пам'ятайте про `setMouseTracking(true)` для відстеження без натиснутої кнопки.
      - `mouseDoubleClickEvent(QMouseEvent *event)`: Подвійне натискання.
      Ви можете отримати координати події (`event->pos()`) та інформацію про натиснуті кнопки (`event->button()`, `event->buttons()`).

   - Події клавіатури:
      - `keyPressEvent(QKeyEvent *event)`: Натискання клавіші.
      - `keyReleaseEvent(QKeyEvent *event)`: Відпускання клавіші.
      Віджет отримує події клавіатури лише тоді, коли він має фокус введення. Ви можете встановити політику фокусу за допомогою setFocusPolicy().

**Приклад обробки подій:**
```cpp
// MyCustomWidget.cpp (продовження)

void MyCustomWidget::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        m_lastMousePos = event->pos(); // Зберігаємо позицію для потенційного перетягування
        qDebug() << "Натиснуто ліву кнопку в: " << event->pos();
        // Змінюємо колір при натисканні
        setWidgetColor(QColor(qrand() % 256, qrand() % 256, qrand() % 256));
    }
    QWidget::mousePressEvent(event); // Викликаємо базовий клас для стандартної обробки
}

void MyCustomWidget::mouseMoveEvent(QMouseEvent *event)
{
    // Якщо ліва кнопка натиснута, можемо реалізувати перетягування
    if (event->buttons() & Qt::LeftButton) {
        // Переміщуємо віджет
        move(pos() + (event->pos() - m_lastMousePos));
        qDebug() << "Віджет переміщено до: " << pos();
    }
    QWidget::mouseMoveEvent(event);
}

void MyCustomWidget::keyPressEvent(QKeyEvent *event)
{
    if (event->key() == Qt::Key_Space) {
        qDebug() << "Натиснуто пробіл! Змінюємо колір на випадковий.";
        setWidgetColor(QColor(qrand() % 256, qrand() % 256, qrand() % 256));
    } else if (event->key() == Qt::Key_Escape) {
        qDebug() << "Натиснуто ESC! Завершуємо роботу програми.";
        QApplication::quit(); // Закриваємо програму
    }
    QWidget::keyPressEvent(event);
}
```

4. **Надання підказок щодо розміру (`sizeHint()`, `minimumSizeHint()`, `setSizePolicy()`)**
Ці методи є критично важливими для правильної інтеграції вашого власного віджета в систему менеджерів розташування Qt (Layouts). Вони повідомляють менеджеру розташування про бажані та мінімальні розміри вашого віджета.
- `QSize sizeHint() const override`: Повертає "ідеальний" або бажаний розмір віджета. Менеджери розташування намагатимуться надати віджету саме такий розмір. Якщо ваш віджет містить фіксовані елементи, ви можете обчислити їхній розмір.

- `QSize minimumSizeHint() const override`: Повертає мінімальний розмір, нижче якого віджет не повинен стискатися. Це запобігає тому, щоб віджет став занадто малим і його вміст став нечитабельним або недоступним.

- `void setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical)`: Вказує, як віджет повинен поводитися, коли доступного простору більше або менше, ніж його sizeHint(). Наприклад, `QSizePolicy::Expanding` дозволяє віджету розтягуватися, щоб зайняти весь доступний простір.

**Приклад реалізації підказок розміру:**
```cpp
// MyCustomWidget.cpp (продовження)

QSize MyCustomWidget::sizeHint() const
{
    // Повертаємо бажаний розмір 200x200 пікселів
    return QSize(200, 200);
}

QSize MyCustomWidget::minimumSizeHint() const
{
    // Повертаємо мінімальний розмір 50x50 пікселів
    return QSize(50, 50);
}
```

5. Власні властивості та сигнали/слоти

Щоб ваш власний віджет був гнучким і міг взаємодіяти з іншими частинами програми, ви можете використовувати:

- Властивості (Properties): За допомогою макросу `Q_PROPERTY` ви можете оголошувати власні властивості для вашого віджета. Це дозволяє отримувати та встановлювати значення властивостей за допомогою уніфікованого API Qt (наприклад, через `QObject::property()` та `QObject::setProperty()`), а також інтегрувати їх у Qt Designer.

    - `Q_PROPERTY(Type name READ getter WRITE setter NOTIFY notifier)`:
        - `Type`: Тип властивості (наприклад, QColor, int, QString).
        - `name`: Ім'я властивості.
        - `READ` getter: Функція для читання значення.
        - `WRITE` setter: Функція для встановлення значення.
        - `NOTIFY` notifier: Сигнал, який випромінюється при зміні значення властивості. Це дозволяє іншим об'єктам реагувати на зміни.

    - Сигнали та слоти: Це основний механізм зв'язку між об'єктами в Qt. Ваш власний віджет може випромінювати сигнали (наприклад, коли користувач щось зробив або змінилася внутрішня властивість) і мати слоти для реагування на сигнали від інших об'єктів.

**Приклад (оголошено в .h, реалізовано в .cpp):**
```cpp
// MyCustomWidget.h (повтор частини)
class MyCustomWidget : public QWidget
{
    Q_OBJECT
    Q_PROPERTY(QColor widgetColor READ widgetColor WRITE setWidgetColor NOTIFY widgetColorChanged)
    // ...
signals:
    void widgetColorChanged(const QColor &color);
    // ...
};

// MyCustomWidget.cpp (продовження)
void MyCustomWidget::setWidgetColor(const QColor &color)
{
    if (m_widgetColor != color) {
        m_widgetColor = color;
        emit widgetColorChanged(m_widgetColor); // Випромінюємо сигнал
        update(); // Перемальовуємо віджет
    }
}
```

6. **Додавання до UI (Qt Designer)**

Після створення власного віджета ви можете інтегрувати його в Qt Designer, що значно прискорює дизайн інтерфейсу.

- "Promote To..." (Підвищити до...):
    - Перетягніть стандартний віджет (наприклад, QWidget або QLabel) на вашу форму в Qt Designer.
    - Клацніть правою кнопкою миші на цьому віджеті та виберіть "Promote To..." (або "Підвищити до..." в українській версії).
    - У діалоговому вікні, що з'явиться:
        - Введіть ім'я класу вашого власного віджета (наприклад, MyCustomWidget).
        - Вкажіть заголовочний файл (наприклад, MyCustomWidget.h).
        - Натисніть "Add" (Додати), а потім "Promote" (Підвищити).
        - Qt Designer запам'ятає, що цей віджет тепер є вашим власним класом. Ви побачите, що його тип зміниться, але візуально він може виглядати як базовий QWidget до запуску програми.
- Властивості в Designer: Якщо ви оголосили властивості за допомогою Q_PROPERTY, вони з'являться в редакторі властивостей Qt Designer, і ви зможете налаштовувати їх прямо там.

**Приклад інтеграції в mainwindow.ui (після "Promote To..."):**
```xml
<!-- Частина mainwindow.ui після "підвищення" стандартного QWidget до MyCustomWidget -->
<widget class="MyCustomWidget" name="myCustomWidgetInstance">
 <property name="geometry">
  <rect>
   <x>50</x>
   <y>50</y>
   <width>200</width>
   <height>200</height>
  </rect>
 </property>
 <!-- Властивість widgetColor, якщо вона Q_PROPERTY і підтримується Designer -->
 <property name="widgetColor" stdset="0">
  <color>
   <red>255</red>
   <green>0</green>
   <blue>0</blue>
  </color>
 </property>
</widget>
```


## Додаткові матеріали для вивчення:

- Офіційна документація Qt 6 по створенню власних віджетів (розділи, що стосуються paintEvent, mouseEvent тощо) https://doc.qt.io/qt-6/qwidget.html
- Офіційна документація Qt 6 по QPainter https://doc.qt.io/qt-6/qpainter.html
- Офіційна документація Qt 6 по системі властивостей Qt https://doc.qt.io/qt-6/properties.html
- Офіційна документація Qt 6 по мета-об'єктній системі https://doc.qt.io/qt-6/metaobjects.html
